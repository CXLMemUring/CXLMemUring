// End-to-End Test: CIRA Compiler -> Vortex Device Offload
// Tests complete pipeline from x86_64 host to Vortex SIMT device

#include "../vortex_device.h"
#include <iostream>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <cassert>

// Test kernel: Vector addition
// This would normally be generated by the CIRA compiler
// For now, we'll use a pre-compiled RISC-V binary or simulate it
void test_vector_add() {
    std::cout << "\n=== Test 1: Vector Addition ===" << std::endl;

    // Initialize device
    vortex_device_h device;
    int ret = vortex_device_init(&device, "/root/CXLMemUring/vortex/sim/rtlsim/rtlsim");
    assert(ret == VORTEX_SUCCESS && "Device initialization failed");

    // Get device capabilities
    vortex_device_caps_t caps;
    ret = vortex_device_get_caps(device, &caps);
    assert(ret == VORTEX_SUCCESS);

    std::cout << "Device Capabilities:" << std::endl;
    std::cout << "  Cores: " << caps.num_cores << std::endl;
    std::cout << "  Warps/Core: " << caps.num_warps_per_core << std::endl;
    std::cout << "  Threads/Warp: " << caps.num_threads_per_warp << std::endl;

    // Prepare test data
    const size_t N = 256;
    const size_t data_size = N * sizeof(float);

    std::vector<float> h_a(N);
    std::vector<float> h_b(N);
    std::vector<float> h_c(N, 0.0f);
    std::vector<float> h_expected(N);

    // Initialize input arrays
    for (size_t i = 0; i < N; i++) {
        h_a[i] = static_cast<float>(i);
        h_b[i] = static_cast<float>(i * 2);
        h_expected[i] = h_a[i] + h_b[i];
    }

    // Allocate device memory
    vortex_buffer_h d_a, d_b, d_c;
    ret = vortex_malloc(device, &d_a, data_size);
    assert(ret == VORTEX_SUCCESS);

    ret = vortex_malloc(device, &d_b, data_size);
    assert(ret == VORTEX_SUCCESS);

    ret = vortex_malloc(device, &d_c, data_size);
    assert(ret == VORTEX_SUCCESS);

    std::cout << "Allocated " << (data_size * 3) << " bytes on device" << std::endl;

    // Copy data to device
    ret = vortex_memcpy(d_a, h_a.data(), data_size, VORTEX_MEMCPY_HOST_TO_DEVICE);
    assert(ret == VORTEX_SUCCESS);

    ret = vortex_memcpy(d_b, h_b.data(), data_size, VORTEX_MEMCPY_HOST_TO_DEVICE);
    assert(ret == VORTEX_SUCCESS);

    std::cout << "Copied input data to device" << std::endl;

    // Load kernel (would be compiler output in real scenario)
    // For testing, we'll check if we can load a kernel file
    // This kernel should be compiled from LLVM IR to RISC-V
    const char* kernel_path = "/root/CXLMemUring/test/kernels/vector_add.riscv";

    vortex_kernel_h kernel;
    // For now, since we may not have the compiled kernel, we'll create a dummy one
    // In a real scenario, this would be the output from CiraToLLVM -> LLVM -> RISC-V compilation
    std::cout << "Note: Kernel loading test (kernel file may not exist yet)" << std::endl;

    // Get buffer addresses
    uint64_t addr_a, addr_b, addr_c;
    vortex_buffer_get_address(d_a, &addr_a);
    vortex_buffer_get_address(d_b, &addr_b);
    vortex_buffer_get_address(d_c, &addr_c);

    uint32_t n_val = N;

    std::cout << "  Buffer A at: 0x" << std::hex << addr_a << std::dec << std::endl;
    std::cout << "  Buffer B at: 0x" << std::hex << addr_b << std::dec << std::endl;
    std::cout << "  Buffer C at: 0x" << std::hex << addr_c << std::dec << std::endl;

    // Cleanup
    vortex_free(d_a);
    vortex_free(d_b);
    vortex_free(d_c);

    vortex_device_destroy(device);

    std::cout << "Test completed successfully (kernel execution skipped - needs compiled binary)" << std::endl;
}

// Test kernel: Data transfer and LLC interaction
void test_data_transfer() {
    std::cout << "\n=== Test 2: Host-Device Data Transfer ===" << std::endl;

    vortex_device_h device;
    int ret = vortex_device_init(&device, "/root/CXLMemUring/vortex/sim/rtlsim/rtlsim");
    assert(ret == VORTEX_SUCCESS);

    // Enable debug output
    vortex_device_set_debug(device, 1);

    const size_t buffer_size = 4096;  // 4KB buffer
    std::vector<uint8_t> host_data(buffer_size);
    std::vector<uint8_t> readback_data(buffer_size, 0);

    // Initialize with pattern
    for (size_t i = 0; i < buffer_size; i++) {
        host_data[i] = static_cast<uint8_t>(i & 0xFF);
    }

    // Allocate device buffer
    vortex_buffer_h d_buffer;
    ret = vortex_malloc(device, &d_buffer, buffer_size);
    assert(ret == VORTEX_SUCCESS);

    // Transfer to device
    ret = vortex_memcpy(d_buffer, host_data.data(), buffer_size,
                       VORTEX_MEMCPY_HOST_TO_DEVICE);
    assert(ret == VORTEX_SUCCESS);

    std::cout << "Transferred " << buffer_size << " bytes to device" << std::endl;

    // Transfer back from device
    ret = vortex_memcpy(readback_data.data(), d_buffer, buffer_size,
                       VORTEX_MEMCPY_DEVICE_TO_HOST);
    assert(ret == VORTEX_SUCCESS);

    std::cout << "Read back " << buffer_size << " bytes from device" << std::endl;

    // Verify data
    bool match = true;
    for (size_t i = 0; i < buffer_size; i++) {
        if (host_data[i] != readback_data[i]) {
            std::cerr << "Mismatch at index " << i << ": expected "
                      << (int)host_data[i] << ", got " << (int)readback_data[i] << std::endl;
            match = false;
            break;
        }
    }

    if (match) {
        std::cout << "Data verification: PASSED" << std::endl;
    } else {
        std::cout << "Data verification: FAILED" << std::endl;
    }

    vortex_free(d_buffer);
    vortex_device_destroy(device);
}

// Test memory coalescing and LLC usage
void test_memory_coalescing() {
    std::cout << "\n=== Test 3: Memory Coalescing and Cache Behavior ===" << std::endl;

    vortex_device_h device;
    int ret = vortex_device_init(&device, "/root/CXLMemUring/vortex/sim/rtlsim/rtlsim");
    assert(ret == VORTEX_SUCCESS);

    vortex_device_caps_t caps;
    vortex_device_get_caps(device, &caps);

    std::cout << "Cache line size: " << caps.cache_line_size << " bytes" << std::endl;

    // Allocate buffer aligned to cache lines
    const size_t num_cache_lines = 64;
    const size_t buffer_size = num_cache_lines * caps.cache_line_size;

    vortex_buffer_h d_buffer;
    ret = vortex_malloc(device, &d_buffer, buffer_size);
    assert(ret == VORTEX_SUCCESS);

    uint64_t dev_addr;
    vortex_buffer_get_address(d_buffer, &dev_addr);

    std::cout << "Allocated buffer at 0x" << std::hex << dev_addr << std::dec << std::endl;
    std::cout << "Buffer size: " << buffer_size << " bytes (" << num_cache_lines
              << " cache lines)" << std::endl;

    // Test sequential access pattern (good for LLC)
    std::vector<uint8_t> sequential_data(buffer_size);
    for (size_t i = 0; i < buffer_size; i++) {
        sequential_data[i] = static_cast<uint8_t>(i);
    }

    ret = vortex_memcpy(d_buffer, sequential_data.data(), buffer_size,
                       VORTEX_MEMCPY_HOST_TO_DEVICE);
    assert(ret == VORTEX_SUCCESS);

    std::cout << "Sequential write test completed" << std::endl;

    vortex_free(d_buffer);
    vortex_device_destroy(device);
}

int main(int argc, char** argv) {
    std::cout << "================================================" << std::endl;
    std::cout << "Vortex End-to-End Offload Test Suite" << std::endl;
    std::cout << "Tests CIRA Runtime -> Vortex Device Pipeline" << std::endl;
    std::cout << "================================================" << std::endl;

    try {
        // Test 1: Basic vector addition setup
        test_vector_add();

        // Test 2: Data transfer verification
        test_data_transfer();

        // Test 3: Memory coalescing and cache behavior
        test_memory_coalescing();

        std::cout << "\n================================================" << std::endl;
        std::cout << "All tests completed successfully!" << std::endl;
        std::cout << "================================================" << std::endl;

        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Test failed with exception: " << e.what() << std::endl;
        return 1;
    }
}
